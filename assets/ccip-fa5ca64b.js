import{B as l,a as w,s as m,i as h,I as y,d as O,b as E,f as L,h as x,H as b,j as R}from"./index-f9c7ed29.js";(function(){try{var e=typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{},t=new Error().stack;t&&(e._sentryDebugIds=e._sentryDebugIds||{},e._sentryDebugIds[t]="1c1e4c7a-3ee4-4d0a-b2b6-6d1ef5209130",e._sentryDebugIdIdentifier="sentry-dbid-1c1e4c7a-3ee4-4d0a-b2b6-6d1ef5209130")}catch{}})();class M extends l{constructor({callbackSelector:t,cause:r,data:o,extraData:c,sender:i,urls:s}){super(r.shortMessage||"An error occurred while fetching for an offchain result.",{cause:r,metaMessages:[...r.metaMessages||[],r.metaMessages?.length?"":[],"Offchain Gateway Call:",s&&["  Gateway URL(s):",...s.map(d=>`    ${w(d)}`)],`  Sender: ${i}`,`  Data: ${o}`,`  Callback selector: ${t}`,`  Extra data: ${c}`].flat()}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"OffchainLookupError"})}}class D extends l{constructor({result:t,url:r}){super("Offchain gateway response is malformed. Response data must be a hex value.",{metaMessages:[`Gateway URL: ${w(r)}`,`Response: ${m(t)}`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"OffchainLookupResponseMalformedError"})}}class $ extends l{constructor({sender:t,to:r}){super("Reverted sender address does not match target contract address (`to`).",{metaMessages:[`Contract address: ${r}`,`OffchainLookup sender address: ${t}`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"OffchainLookupSenderMismatchError"})}}function I(e,t){if(!h(e,{strict:!1}))throw new y({address:e});if(!h(t,{strict:!1}))throw new y({address:t});return e.toLowerCase()===t.toLowerCase()}const j="0x556f1830",S={name:"OffchainLookup",type:"error",inputs:[{name:"sender",type:"address"},{name:"urls",type:"string[]"},{name:"callData",type:"bytes"},{name:"callbackFunction",type:"bytes4"},{name:"extraData",type:"bytes"}]};async function q(e,{blockNumber:t,blockTag:r,data:o,to:c}){const{args:i}=O({data:o,abi:[S]}),[s,d,a,n,p]=i,{ccipRead:u}=e,g=u&&typeof u?.request=="function"?u.request:v;try{if(!I(c,s))throw new $({sender:s,to:c});const f=await g({data:a,sender:s,urls:d}),{data:k}=await E(e,{blockNumber:t,blockTag:r,data:L([n,x([{type:"bytes"},{type:"bytes"}],[f,p])]),to:c});return k}catch(f){throw new M({callbackSelector:n,cause:f,data:o,extraData:p,sender:s,urls:d})}}async function v({data:e,sender:t,urls:r}){let o=new Error("An unknown error occurred.");for(let c=0;c<r.length;c++){const i=r[c],s=i.includes("{data}")?"GET":"POST",d=s==="POST"?{data:e,sender:t}:void 0;try{const a=await fetch(i.replace("{sender}",t).replace("{data}",e),{body:JSON.stringify(d),method:s});let n;if(a.headers.get("Content-Type")?.startsWith("application/json")?n=(await a.json()).data:n=await a.text(),!a.ok){o=new b({body:d,details:n?.error?m(n.error):a.statusText,headers:a.headers,status:a.status,url:i});continue}if(!R(n)){o=new D({result:n,url:i});continue}return n}catch(a){o=new b({body:d,details:a.message,url:i})}}throw o}export{v as ccipRequest,q as offchainLookup,S as offchainLookupAbiItem,j as offchainLookupSignature};
